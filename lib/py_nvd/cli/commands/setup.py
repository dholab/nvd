# ruff: noqa: B008
"""
Setup command for the NVD CLI.

Commands:
    nvd setup      - Interactive first-run setup for NVD
    nvd shell-hook - Output shell integration code
"""

from __future__ import annotations

import getpass
import os
import shutil
import socket
import sqlite3
import subprocess
import tempfile
from datetime import UTC, datetime
from pathlib import Path

import typer
from rich.console import Console
from rich.panel import Panel
from rich.syntax import Syntax

from py_nvd import __version__
from py_nvd.cli.utils import (
    console,
    error,
    get_editor,
    info,
    success,
    warning,
)

# Separate console for stderr output (used by shell-hook to not pollute stdout)
stderr_console = Console(stderr=True)

# Default paths
NVD_HOME = Path.home() / ".nvd"
CHTC_DEFAULT_STATE_DIR = Path("/staging/groups/oconnor_group/nvd/state-db")


def _is_oconnor_chtc() -> bool:
    """
    Detect if running on O'Connor lab CHTC access point.

    Checks hostname pattern: oconnor-ap*.chtc.wisc.edu
    """
    hostname = socket.gethostname()
    fqdn = socket.getfqdn()
    return hostname.startswith("oconnor-ap") and "chtc.wisc.edu" in fqdn


def _detect_shell() -> str | None:
    """
    Detect the user's shell from $SHELL environment variable.

    Returns:
        "bash", "zsh", or None if unrecognized.
    """
    shell_path = os.environ.get("SHELL", "")
    if not shell_path:
        return None

    shell_name = Path(shell_path).name
    if shell_name in ("bash", "zsh"):
        return shell_name

    return None


def _check_pixi_installed() -> bool:
    """
    Check if pixi is available on the system PATH.

    The wrapper script generated by setup uses `pixi run` to invoke nvd,
    so pixi must be globally installed for the wrapper to work.
    """
    return shutil.which("pixi") is not None


def _get_chtc_template_path() -> Path:
    """Get path to the CHTC config template shipped with the package."""
    # The template is in conf/ relative to the package root
    # We can find it relative to this file's location
    this_file = Path(__file__)
    # setup.py is at lib/py_nvd/cli/commands/setup.py
    # conf/ is at repo root, so go up 5 levels
    repo_root = this_file.parent.parent.parent.parent.parent
    return repo_root / "conf" / "chtc-template.config"


def _load_and_substitute_template(template_path: Path) -> str:
    """
    Load a config template and substitute variables.

    Variables substituted:
        ${HOSTNAME} - Current hostname
        ${USER} - Current username
        ${DATE} - Current date in ISO format
        ${VERSION} - NVD version
        ${HOME} - User's home directory (literal $HOME for Nextflow)
    """
    if not template_path.exists():
        raise FileNotFoundError(f"Template not found: {template_path}")

    template = template_path.read_text()

    # Substitute variables
    # Note: ${HOME} is left as literal $HOME for Nextflow to expand at runtime
    substitutions = {
        "${HOSTNAME}": socket.gethostname(),
        "${USER}": getpass.getuser(),
        "${DATE}": datetime.now(UTC).strftime("%Y-%m-%d"),
        "${VERSION}": __version__,
        # ${HOME} is intentionally NOT substituted - Nextflow needs it as-is
    }

    result = template
    for var, value in substitutions.items():
        result = result.replace(var, value)

    return result


def _preview_config(config_content: str) -> None:
    """Display config preview with syntax highlighting."""
    syntax = Syntax(
        config_content,
        "groovy",  # Nextflow config is Groovy-based
        theme="monokai",
        line_numbers=True,
    )
    panel = Panel(
        syntax,
        title="Generated user.config",
        border_style="cyan",
    )
    console.print(panel)


def _edit_config_in_editor(config_content: str) -> str:
    """
    Open config in user's editor and return the edited content.

    Creates a temp file, opens it in the editor, waits for the editor
    to exit, then reads and returns the (possibly modified) content.
    """
    editor = get_editor()

    # Create temp file with .config extension for editor syntax highlighting
    with tempfile.NamedTemporaryFile(
        mode="w",
        suffix=".config",
        delete=False,
    ) as f:
        f.write(config_content)
        temp_path = Path(f.name)

    try:
        # Open editor and wait for it to exit
        subprocess.run([editor, str(temp_path)], check=True)

        # Read back the (possibly edited) content
        return temp_path.read_text()
    finally:
        # Clean up temp file
        temp_path.unlink(missing_ok=True)


def _write_config(config_content: str, config_path: Path) -> None:
    """Write config to file, creating parent directories if needed."""
    config_path.parent.mkdir(parents=True, exist_ok=True)
    config_path.write_text(config_content)


DEFAULT_WRAPPER_DIR = Path.home() / ".local" / "bin"

WRAPPER_TEMPLATE = """\
#!/bin/bash
# NVD wrapper - runs nvd directly from pixi environment
# Generated by: nvd setup v{version}
# Date: {date}
#
# This wrapper sets PATH to include pixi environment binaries (for nextflow, etc.)
# but only for the nvd process - it doesn't pollute the user's shell PATH.

NVD_REPO="{nvd_repo}"
NVD_BIN="$NVD_REPO/.pixi/envs/default/bin"

# Verify the environment exists
if [[ ! -x "$NVD_BIN/nvd" ]]; then
    echo "Error: nvd not found at $NVD_BIN/nvd" >&2
    echo "Run 'pixi install' in $NVD_REPO to set up the environment." >&2
    exit 1
fi

# Run nvd with pixi bin on PATH (for subprocess access to nextflow, etc.)
PATH="$NVD_BIN:$PATH" exec "$NVD_BIN/nvd" "$@"
"""

SETUP_CONF_TEMPLATE = """\
# NVD setup configuration
# Generated by: nvd setup v{version}
# Date: {date}

NVD_REPO={nvd_repo}
NVD_STATE_DIR={state_dir}
{default_profile_line}
"""

# Profile line templates
_PROFILE_LINE_SET = "NVD_DEFAULT_PROFILE={profile}"
_PROFILE_LINE_COMMENT = """\
# Default Nextflow profile for 'nvd run' (optional)
# Uncomment and set to use a custom profile by default:
# NVD_DEFAULT_PROFILE=my_profile"""


def _find_nvd_repo() -> Path:
    """
    Find the NVD repository root.

    Looks for the repo by traversing up from this file's location,
    looking for pyproject.toml with the nvd package.
    """
    # This file is at lib/py_nvd/cli/commands/setup.py
    # Repo root is 5 levels up
    this_file = Path(__file__)
    repo_root = this_file.parent.parent.parent.parent.parent

    # Verify it looks like the NVD repo
    pyproject = repo_root / "pyproject.toml"
    if pyproject.exists() and "nvd" in pyproject.read_text():
        return repo_root.resolve()

    raise FileNotFoundError(
        f"Could not find NVD repository root. Expected pyproject.toml at: {pyproject}",
    )


def _get_stable_repo_path(repo_path: Path) -> Path:
    """
    Get a stable path to the NVD repo that survives version upgrades.

    If the repo is installed in the versioned directory structure
    (~/.nvd/v{version}/), returns ~/.nvd/latest instead of the versioned
    path. This ensures that setup.conf and the wrapper script remain
    valid after upgrades that rename the versioned directory.

    For repos in other locations (e.g., development clones), returns
    the original path unchanged.
    """
    resolved = repo_path.resolve()
    nvd_home = (Path.home() / ".nvd").resolve()
    latest_link = nvd_home / "latest"

    is_versioned_install = resolved.parent == nvd_home and resolved.name.startswith("v")
    if not is_versioned_install:
        return resolved

    if not latest_link.is_symlink():
        return resolved

    try:
        latest_points_here = latest_link.resolve() == resolved
    except OSError:
        return resolved

    if not latest_points_here:
        return resolved

    return latest_link


def _generate_wrapper_script(nvd_repo: Path) -> str:
    """Generate the wrapper script content."""
    return WRAPPER_TEMPLATE.format(
        version=__version__,
        date=datetime.now(UTC).strftime("%Y-%m-%d"),
        nvd_repo=nvd_repo,
    )


def _generate_setup_conf(
    nvd_repo: Path,
    state_dir: Path,
    default_profile: str | None = None,
) -> str:
    """Generate the setup.conf content."""
    if default_profile:
        profile_line = _PROFILE_LINE_SET.format(profile=default_profile)
    else:
        profile_line = _PROFILE_LINE_COMMENT

    return SETUP_CONF_TEMPLATE.format(
        version=__version__,
        date=datetime.now(UTC).strftime("%Y-%m-%d"),
        nvd_repo=nvd_repo,
        state_dir=state_dir,
        default_profile_line=profile_line,
    )


def _install_wrapper_script(
    nvd_repo: Path,
    wrapper_dir: Path = DEFAULT_WRAPPER_DIR,
) -> Path:
    """
    Install the wrapper script.

    Creates the wrapper directory if needed, writes the script,
    and makes it executable.

    Returns the path to the installed wrapper.
    """
    wrapper_dir.mkdir(parents=True, exist_ok=True)
    wrapper_path = wrapper_dir / "nvd"

    wrapper_content = _generate_wrapper_script(nvd_repo)
    wrapper_path.write_text(wrapper_content)

    # Make executable (chmod +x)
    wrapper_path.chmod(wrapper_path.stat().st_mode | 0o111)

    return wrapper_path


def _write_setup_conf(
    nvd_repo: Path,
    state_dir: Path,
    default_profile: str | None = None,
) -> Path:
    """
    Write the setup.conf file to ~/.nvd/.

    This file stores the NVD_REPO path, state directory, and optional
    default profile for the shell hook and nvd run to read.
    """
    conf_path = NVD_HOME / "setup.conf"
    conf_path.parent.mkdir(parents=True, exist_ok=True)

    conf_content = _generate_setup_conf(nvd_repo, state_dir, default_profile)
    conf_path.write_text(conf_content)

    return conf_path


def _generate_completions(shell_type: str) -> Path:
    """
    Generate static shell completion file.

    Creates a completion script at ~/.nvd/completions.{shell} that can be
    sourced directly, avoiding the need to run nvd on every shell startup.

    Args:
        shell_type: "bash" or "zsh"

    Returns:
        Path to the generated completion file.
    """
    from typer._completion_shared import get_completion_script

    assert shell_type in ("bash", "zsh"), f"Unsupported shell: {shell_type}"

    script = get_completion_script(
        prog_name="nvd",
        complete_var="_NVD_COMPLETE",
        shell=shell_type,
    )

    completions_path = NVD_HOME / f"completions.{shell_type}"
    completions_path.parent.mkdir(parents=True, exist_ok=True)
    completions_path.write_text(script)

    return completions_path


SHELL_HOOK_MARKER = "nvd setup shell-hook"


def _get_rc_file(shell_type: str) -> Path:
    """Get the RC file path for the given shell type."""
    if shell_type == "zsh":
        return Path.home() / ".zshrc"
    # bash
    return Path.home() / ".bashrc"


def _is_hook_installed(rc_file: Path) -> bool:
    """Check if the shell hook is already installed in the RC file."""
    if not rc_file.exists():
        return False
    return SHELL_HOOK_MARKER in rc_file.read_text()


def _install_shell_hook(rc_file: Path) -> bool:
    """
    Install the shell hook into the RC file.

    Appends the eval line to the RC file. Returns True on success,
    False if there was a permission error.
    """
    hook_line = f'eval "$({SHELL_HOOK_MARKER})"'
    hook_block = f"""
# NVD shell integration
{hook_line}
"""

    try:
        with rc_file.open("a") as f:
            f.write(hook_block)
        return True
    except PermissionError:
        return False


def _validate_state_dir(path: Path) -> tuple[bool, str]:
    """
    Validate a state directory path.

    Checks:
    1. Path exists or can be created
    2. Path is writable

    Returns:
        (is_valid, message) tuple
    """
    if path.exists():
        if not path.is_dir():
            return False, f"Path exists but is not a directory: {path}"
        # Check if writable by trying to create a temp file
        test_file = path / ".nvd_write_test"
        try:
            test_file.touch()
            test_file.unlink()
            return True, "Directory exists and is writable"
        except PermissionError:
            return False, f"Directory exists but is not writable: {path}"
        except OSError as e:
            return False, f"Directory exists but write test failed: {e}"
    else:
        # Check if parent exists and is writable
        parent = path.parent
        if not parent.exists():
            return False, f"Parent directory does not exist: {parent}"
        # Try to create the directory
        try:
            path.mkdir(parents=True, exist_ok=True)
            return True, f"Created directory: {path}"
        except PermissionError:
            return False, f"Cannot create directory (permission denied): {path}"
        except OSError as e:
            return False, f"Cannot create directory: {e}"


def _check_existing_database(state_dir: Path) -> tuple[bool, str]:
    """
    Check if an existing state database is valid.

    Returns:
        (is_valid, message) tuple. If no database exists, returns (True, "No existing database").
    """
    db_path = state_dir / "state.sqlite"
    if not db_path.exists():
        return True, "No existing database"

    try:
        conn = sqlite3.connect(str(db_path))
        conn.execute("SELECT 1")
        conn.execute("PRAGMA integrity_check")
        conn.close()
        return True, f"Existing database is valid: {db_path}"
    except sqlite3.DatabaseError as e:
        return False, f"Existing database appears corrupted: {e}"


def _prompt_state_dir(default: Path, non_interactive: bool) -> Path:
    """
    Prompt user for state directory with validation.

    In non-interactive mode, just returns the default.
    """
    if non_interactive:
        return default

    console.print(f"State directory [{default}]: ", end="", markup=False)
    user_input = input().strip()

    if not user_input:
        return default

    return Path(user_input).expanduser().resolve()


CONTAINER_IMAGE_URI = "docker://nrminor/nvd:v{version}"


def _get_container_path(version: str) -> Path:
    """Get the path where the container image should be stored."""
    return NVD_HOME / f"nvd-v{version}.sif"


def _pull_apptainer_image(version: str) -> tuple[bool, str]:
    """
    Pull the NVD container image using Apptainer.

    Returns:
        (success, message) tuple
    """
    sif_path = _get_container_path(version)
    image_uri = CONTAINER_IMAGE_URI.format(version=version)

    # Ensure ~/.nvd exists
    sif_path.parent.mkdir(parents=True, exist_ok=True)

    try:
        result = subprocess.run(
            ["apptainer", "pull", "--force", str(sif_path), image_uri],
            check=False,
            capture_output=True,
            text=True,
        )
        if result.returncode == 0:
            return True, f"Container image pulled to {sif_path}"
        return False, f"Apptainer pull failed: {result.stderr}"
    except FileNotFoundError:
        return False, "Apptainer not found. Is it installed?"
    except Exception as e:
        return False, f"Container pull failed: {e}"


setup_app = typer.Typer(
    name="setup",
    help="First-run setup and shell integration",
    no_args_is_help=False,
)


@setup_app.callback(invoke_without_command=True)
def setup(
    ctx: typer.Context,
    non_interactive: bool = typer.Option(
        False,
        "--non-interactive",
        help="Skip all prompts, use defaults or fail if required input missing",
    ),
    shell: str | None = typer.Option(
        None,
        "--shell",
        help="Shell to configure (bash, zsh). Auto-detected if not specified.",
    ),
    state_dir: Path | None = typer.Option(
        None,
        "--state-dir",
        help="State directory for run tracking and taxonomy cache",
    ),
    skip_shell_hook: bool = typer.Option(
        False,
        "--skip-shell-hook",
        help="Don't install shell hook",
    ),
    skip_container: bool = typer.Option(
        False,
        "--skip-container",
        help="Don't pull container image (CHTC only)",
    ),
    force: bool = typer.Option(
        False,
        "--force",
        help="Overwrite existing configuration without prompting",
    ),
) -> None:
    """
    Interactive first-run setup for NVD.

    This command configures NVD for your environment:

    1. Detects your environment (CHTC O'Connor lab vs generic)
    2. Creates ~/.nvd/user.config with appropriate settings
    3. Installs a shell hook for PATH, environment variables, and completions
    4. On CHTC, optionally pre-pulls the Apptainer container image

    After setup, 'nvd' will be available in new shell sessions with
    tab completion and the correct state directory configured.

    Examples:

        # Interactive setup (recommended for first-time users)
        nvd setup

        # Non-interactive setup with custom state directory
        nvd setup --non-interactive --state-dir /scratch/nvd

        # Re-run setup, overwriting existing config
        nvd setup --force
    """
    # If a subcommand was invoked, don't run the main setup
    if ctx.invoked_subcommand is not None:
        return

    info("NVD Setup")
    console.print()

    # Check for pixi first - required for wrapper script
    if not _check_pixi_installed():
        error(
            "pixi not found\n\n"
            "NVD requires pixi for environment management. Install it with:\n"
            "  curl -fsSL https://pixi.sh/install.sh | bash\n\n"
            "Then run 'nvd setup' again.",
        )
        raise typer.Exit(1)

    # Detect environment
    is_chtc = _is_oconnor_chtc()
    if is_chtc:
        console.print(
            f"[green]Detected:[/green] CHTC O'Connor Lab access point ({socket.getfqdn()})",
        )
    else:
        console.print("[green]Detected:[/green] Generic system")

    # Detect shell (use provided or auto-detect)
    detected_shell = shell or _detect_shell()
    if detected_shell:
        console.print(f"[green]Detected shell:[/green] {detected_shell}")
    else:
        warning("Could not detect shell from $SHELL")

    console.print()

    config_path = NVD_HOME / "user.config"
    should_write_config = False

    if is_chtc:
        # Check if config already exists
        if config_path.exists() and not force:
            if non_interactive:
                warning(f"Config already exists: {config_path}")
                warning("Use --force to overwrite")
                # Don't write config, but continue to wrapper script installation
            else:
                console.print(f"[yellow]Config already exists:[/yellow] {config_path}")
                overwrite = typer.confirm("Overwrite existing config?", default=False)
                if overwrite:
                    should_write_config = True
                else:
                    info("Keeping existing config")
                    console.print()
        else:
            should_write_config = True

        if should_write_config:
            # Load and substitute template
            template_path = _get_chtc_template_path()
            if not template_path.exists():
                error(f"CHTC config template not found: {template_path}")
                raise typer.Exit(1)

            config_content = _load_and_substitute_template(template_path)

            # Preview config
            console.print("Setting up NVD for CHTC HTCondor/OSPool execution...")
            console.print()
            _preview_config(config_content)
            console.print()

            # Offer to edit (interactive mode only)
            if not non_interactive:
                edit = typer.confirm("Edit this config in your editor?", default=False)
                if edit:
                    info(f"Opening in {get_editor()}...")
                    config_content = _edit_config_in_editor(config_content)
                    console.print()
                    console.print("[dim]Edited config:[/dim]")
                    _preview_config(config_content)
                    console.print()

            # Write config
            _write_config(config_content, config_path)
            success(f"Configuration written to {config_path}")
            console.print()

    else:
        # Generic system - config is optional
        if not non_interactive:
            console.print(
                "[dim]On generic systems, a user.config is not required for basic "
                "Docker/Apptainer usage.[/dim]",
            )
            create_config = typer.confirm(
                "Would you like to create a user.config anyway?",
                default=False,
            )
            if create_config:
                info("Custom config creation not yet implemented for generic systems")
        console.print()

    if state_dir is not None:
        # User provided explicit state_dir via CLI
        effective_state_dir = state_dir.expanduser().resolve()
    elif is_chtc:
        default_state_dir = CHTC_DEFAULT_STATE_DIR
        effective_state_dir = _prompt_state_dir(default_state_dir, non_interactive)
    else:
        default_state_dir = NVD_HOME
        effective_state_dir = _prompt_state_dir(default_state_dir, non_interactive)

    # Validate state directory
    is_valid, message = _validate_state_dir(effective_state_dir)
    if not is_valid:
        error(f"Invalid state directory: {message}")
        raise typer.Exit(1)

    # Check existing database if present
    db_valid, db_message = _check_existing_database(effective_state_dir)
    if not db_valid:
        warning(db_message)
        if not non_interactive:
            proceed = typer.confirm(
                "Continue anyway? (existing data may be lost)", default=False
            )
            if not proceed:
                raise typer.Exit(1)

    console.print(f"[green]State directory:[/green] {effective_state_dir}")
    console.print()

    try:
        nvd_repo_raw = _find_nvd_repo()
        # Use stable path (latest symlink) for versioned installs
        nvd_repo = _get_stable_repo_path(nvd_repo_raw)
    except FileNotFoundError as e:
        error(str(e))
        raise typer.Exit(1)

    # Check if wrapper already exists
    wrapper_path = DEFAULT_WRAPPER_DIR / "nvd"
    if wrapper_path.exists() and not force:
        if non_interactive:
            warning(f"Wrapper script already exists: {wrapper_path}")
            warning("Use --force to overwrite")
        else:
            console.print(
                f"[yellow]Wrapper script already exists:[/yellow] {wrapper_path}"
            )
            overwrite = typer.confirm("Overwrite existing wrapper?", default=False)
            if not overwrite:
                info("Keeping existing wrapper script")
            else:
                _install_wrapper_script(nvd_repo, DEFAULT_WRAPPER_DIR)
                success(f"Wrapper script installed to {wrapper_path}")
    else:
        _install_wrapper_script(nvd_repo, DEFAULT_WRAPPER_DIR)
        success(f"Wrapper script installed to {wrapper_path}")

    # Determine default profile (CHTC uses chtc_htc profile from user.config)
    default_profile = "chtc_htc" if is_chtc else None

    # Write setup.conf
    conf_path = _write_setup_conf(nvd_repo, effective_state_dir, default_profile)
    success(f"Setup config written to {conf_path}")
    if default_profile:
        info(f"Default profile set to: {default_profile}")

    # Generate shell completions
    if detected_shell:
        completions_path = _generate_completions(detected_shell)
        success(f"Shell completions generated: {completions_path}")
    else:
        # Generate both if we can't detect
        for shell_type in ("bash", "zsh"):
            completions_path = _generate_completions(shell_type)
            info(f"Generated {shell_type} completions: {completions_path}")

    console.print()

    if not skip_shell_hook:
        if detected_shell is None:
            # Can't detect shell - print manual instructions
            warning("Could not detect shell")
            console.print()
            console.print("Add this line to your shell's RC file manually:")
            console.print(f'  [cyan]eval "$({SHELL_HOOK_MARKER})"[/cyan]')
            console.print()
        else:
            rc_file = _get_rc_file(detected_shell)

            if _is_hook_installed(rc_file):
                info(f"Shell hook already installed in {rc_file}")
            elif non_interactive:
                # Just install it
                if _install_shell_hook(rc_file):
                    success(f"Shell hook added to {rc_file}")
                else:
                    warning(f"Could not modify {rc_file} (permission denied)")
                    console.print()
                    console.print("Add this line manually:")
                    console.print(f'  [cyan]eval "$({SHELL_HOOK_MARKER})"[/cyan]')
            else:
                # Ask first
                console.print(f"Add shell hook to {rc_file}?")
                console.print(f'  [dim]eval "$({SHELL_HOOK_MARKER})"[/dim]')
                add_hook = typer.confirm("Proceed?", default=True)

                if add_hook:
                    if _install_shell_hook(rc_file):
                        success(f"Shell hook added to {rc_file}")
                    else:
                        warning(f"Could not modify {rc_file} (permission denied)")
                        console.print()
                        console.print("Add this line manually:")
                        console.print(f'  [cyan]eval "$({SHELL_HOOK_MARKER})"[/cyan]')
                else:
                    info("Skipping shell hook installation")
                    console.print()
                    console.print("To install later, add this to your RC file:")
                    console.print(f'  [cyan]eval "$({SHELL_HOOK_MARKER})"[/cyan]')

            console.print()
    else:
        info("Skipping shell hook installation (--skip-shell-hook)")
        console.print()

    if is_chtc and not skip_container:
        sif_path = _get_container_path(__version__)

        if sif_path.exists():
            info(f"Container image already exists: {sif_path}")
            if not non_interactive:
                repull = typer.confirm("Re-pull container image?", default=False)
                if repull:
                    console.print()
                    console.print(
                        "Pulling container image (~2GB)... [dim]This may take a few minutes.[/dim]",
                    )
                    pull_success, pull_message = _pull_apptainer_image(__version__)
                    if pull_success:
                        success(pull_message)
                    else:
                        warning(pull_message)
                        console.print()
                        console.print("You can pull manually later with:")
                        console.print(
                            f"  [cyan]apptainer pull {sif_path} "
                            f"{CONTAINER_IMAGE_URI.format(version=__version__)}[/cyan]",
                        )
        elif non_interactive:
            # In non-interactive mode, skip container pull by default
            info("Skipping container pull in non-interactive mode")
            console.print()
            console.print("Pull manually with:")
            console.print(
                f"  [cyan]apptainer pull {sif_path} "
                f"{CONTAINER_IMAGE_URI.format(version=__version__)}[/cyan]",
            )
        else:
            console.print()
            console.print(
                "Would you like to pull the container image now? [dim](~2GB download)[/dim]",
            )
            pull_now = typer.confirm("Proceed?", default=True)

            if pull_now:
                console.print()
                console.print(
                    "Pulling container image... [dim]This may take a few minutes.[/dim]",
                )
                pull_success, pull_message = _pull_apptainer_image(__version__)
                if pull_success:
                    success(pull_message)
                else:
                    warning(pull_message)
                    console.print()
                    console.print("You can pull manually later with:")
                    console.print(
                        f"  [cyan]apptainer pull {sif_path} "
                        f"{CONTAINER_IMAGE_URI.format(version=__version__)}[/cyan]",
                    )
            else:
                info("Skipping container pull")
                console.print()
                console.print("Pull manually later with:")
                console.print(
                    f"  [cyan]apptainer pull {sif_path} "
                    f"{CONTAINER_IMAGE_URI.format(version=__version__)}[/cyan]",
                )

        console.print()

    elif is_chtc and skip_container:
        info("Skipping container pull (--skip-container)")
        console.print()
        console.print("Pull manually later with:")
        sif_path = _get_container_path(__version__)
        console.print(
            f"  [cyan]apptainer pull {sif_path} "
            f"{CONTAINER_IMAGE_URI.format(version=__version__)}[/cyan]",
        )
        console.print()

    success("Setup complete!")
    console.print()
    if detected_shell:
        console.print(
            f"Run [cyan]source {_get_rc_file(detected_shell)}[/cyan] "
            "or start a new shell to activate.",
        )
    else:
        console.print("Start a new shell to activate.")
    console.print()


@setup_app.command("shell-hook")
def shell_hook(
    shell: str | None = typer.Option(
        None,
        "--shell",
        help="Shell type (bash, zsh). Auto-detected from $SHELL if not specified.",
    ),
) -> None:
    """
    Output shell integration code.

    This command outputs shell code that should be added to your RC file
    (~/.bashrc or ~/.zshrc). The code sets up:

    1. PATH to include the nvd wrapper
    2. NVD_STATE_DIR environment variable
    3. Shell completions for the nvd command

    Typically installed via 'nvd setup', but can be used manually:

        # Add to ~/.bashrc or ~/.zshrc:
        eval "$(nvd setup shell-hook)"

        # Or specify shell explicitly:
        eval "$(nvd setup shell-hook --shell zsh)"
    """
    # Detect shell (use provided or auto-detect)
    detected_shell = shell or _detect_shell()

    if detected_shell is None:
        # Can't detect shell - print generic message to stderr,
        # but still output something usable
        stderr_console.print(
            "[yellow]âš [/yellow]  Could not detect shell. Assuming bash-compatible syntax.",
        )
        detected_shell = "bash"

    if detected_shell not in ("bash", "zsh"):
        error(f"Unsupported shell: {detected_shell}. Only bash and zsh are supported.")
        raise typer.Exit(1)

    # Read state_dir from setup.conf if it exists
    setup_conf_path = NVD_HOME / "setup.conf"
    state_dir_value = str(NVD_HOME)  # Default

    if setup_conf_path.exists():
        for line in setup_conf_path.read_text().splitlines():
            if line.startswith("NVD_STATE_DIR="):
                state_dir_value = line.split("=", 1)[1].strip()
                break

    # Path to static completions file
    completions_file = NVD_HOME / f"completions.{detected_shell}"

    # Output shell code to stdout (this is what gets eval'd)
    # Using print() directly to avoid Rich formatting
    print(f"""\
# NVD shell integration
# Generated by nvd v{__version__}

# Wrapper script location
export PATH="$HOME/.local/bin:$PATH"

# State directory
export NVD_STATE_DIR="{state_dir_value}"

# Shell completions ({detected_shell})
# Sourced from static file for fast shell startup
if [[ -f "{completions_file}" ]]; then
    source "{completions_file}"
fi
""")
